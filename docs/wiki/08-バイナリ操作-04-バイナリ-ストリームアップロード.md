# バイナリのストリームアップロード - binaries/upload (Bearer認証)

## 概要

Bearer認証を使用してファイルをマルチパートフォームデータとしてアップロードします。Base64エンコードが不要なため、大きなファイルのアップロードに適しています。また、分割（チャンク）アップロードにも対応しています。

## 対応バージョン

- プリザンター 1.3.13.0以降
  - このライブラリの制約によるもの

## 特徴

- **Bearer認証**: `Authorization: Bearer {ApiKey}` ヘッダーを使用
- **マルチパートフォームデータ**: Base64エンコード不要で効率的
- **分割アップロード**: Content-Rangeヘッダーによる大容量ファイルの分割転送
- **ファイルハッシュ検証**: 最終チャンクでのデータ整合性確認

## メソッド

### 新規アップロード

```csharp
// ストリーム版
Task<ApiResponse<UploadBinaryResponse>> UploadBinaryStreamAsync(
    long siteId,
    Stream fileStream,
    string fileName,
    string? contentType = null,
    TimeSpan? timeout = null)

// バイト配列版
Task<ApiResponse<UploadBinaryResponse>> UploadBinaryStreamAsync(
    long siteId,
    byte[] fileData,
    string fileName,
    string? contentType = null,
    TimeSpan? timeout = null)

// ファイルパス版
Task<ApiResponse<UploadBinaryResponse>> UploadBinaryStreamFromFileAsync(
    long siteId,
    string filePath,
    string? contentType = null,
    TimeSpan? timeout = null)
```

### 既存ファイル更新

```csharp
// ストリーム版
Task<ApiResponse<UploadBinaryResponse>> UpdateBinaryStreamAsync(
    string guid,
    Stream fileStream,
    string fileName,
    string? contentType = null,
    bool overwrite = false,
    TimeSpan? timeout = null)

// バイト配列版
Task<ApiResponse<UploadBinaryResponse>> UpdateBinaryStreamAsync(
    string guid,
    byte[] fileData,
    string fileName,
    string? contentType = null,
    bool overwrite = false,
    TimeSpan? timeout = null)
```

### 分割アップロード

```csharp
// 新規チャンクアップロード
Task<ApiResponse<UploadBinaryResponse>> UploadBinaryChunkAsync(
    long siteId,
    byte[] chunkData,
    string fileName,
    long rangeFrom,
    long rangeTo,
    long rangeTotal,
    string? contentType = null,
    string? fileHash = null,
    TimeSpan? timeout = null)

// 既存ファイルチャンク更新
Task<ApiResponse<UploadBinaryResponse>> UpdateBinaryChunkAsync(
    string guid,
    byte[] chunkData,
    string fileName,
    long rangeFrom,
    long rangeTo,
    long rangeTotal,
    string? contentType = null,
    bool overwrite = false,
    string? fileHash = null,
    TimeSpan? timeout = null)
```

## パラメータ

### 共通パラメータ

| 引数 | 型 | 必須 | 説明 |
|------|------|:----:|------|
| `siteId` | long | ✓ | サイトID |
| `guid` | string | ✓ | 更新対象のファイルGUID |
| `fileStream` | Stream | ✓ | ファイルストリーム |
| `fileData` | byte[] | ✓ | ファイルデータ（バイト配列） |
| `filePath` | string | ✓ | ファイルパス |
| `fileName` | string | ✓ | ファイル名 |
| `contentType` | string? | | コンテンツタイプ |
| `overwrite` | bool | | 上書きモード（デフォルト: false） |
| `timeout` | TimeSpan? | | リクエストタイムアウト |

### 分割アップロード用パラメータ

| 引数 | 型 | 必須 | 説明 |
|------|------|:----:|------|
| `chunkData` | byte[] | ✓ | チャンクデータ |
| `rangeFrom` | long | ✓ | Content-Rangeの開始バイト位置 |
| `rangeTo` | long | ✓ | Content-Rangeの終了バイト位置 |
| `rangeTotal` | long | ✓ | ファイル全体のバイトサイズ |
| `fileHash` | string? | | ファイルハッシュ（最終チャンク時に検証用） |

## レスポンス

`UploadBinaryResponseData` には以下のプロパティが含まれます：

| プロパティ | 型 | 説明 |
|------------|------|------|
| `Guid` | string? | アップロードされたファイルのGUID |

## 使用例

### ファイルをストリームでアップロード

```csharp
using var fileStream = File.OpenRead("path/to/large-file.zip");
var result = await client.UploadBinaryStreamAsync(
    siteId: 123,
    fileStream: fileStream,
    fileName: "large-file.zip",
    contentType: "application/zip");

if (result.Data?.StatusCode == 200)
{
    Console.WriteLine($"アップロード完了。GUID: {result.Data.Response?.Guid}");
}
```

### ファイルパスを指定してアップロード

```csharp
var result = await client.UploadBinaryStreamFromFileAsync(
    siteId: 123,
    filePath: "C:/Documents/report.pdf",
    contentType: "application/pdf");
```

### 既存ファイルを更新

```csharp
var result = await client.UpdateBinaryStreamAsync(
    guid: "existing-file-guid",
    fileData: newFileBytes,
    fileName: "updated-file.pdf",
    contentType: "application/pdf",
    overwrite: true);  // 同じGUIDで上書き
```

### 分割アップロード（チャンク）

大きなファイルを複数のチャンクに分割してアップロードする例：

```csharp
var filePath = "path/to/very-large-file.zip";
var fileInfo = new FileInfo(filePath);
var totalSize = fileInfo.Length;
var chunkSize = 1024 * 1024;  // 1MB

using var fileStream = File.OpenRead(filePath);
var buffer = new byte[chunkSize];
var offset = 0L;

while (offset < totalSize)
{
    var bytesToRead = (int)Math.Min(chunkSize, totalSize - offset);
    var bytesRead = await fileStream.ReadAsync(buffer, 0, bytesToRead);
    var chunkData = new byte[bytesRead];
    Array.Copy(buffer, chunkData, bytesRead);
    
    var rangeFrom = offset;
    var rangeTo = offset + bytesRead - 1;
    
    // 最終チャンクの場合はファイルハッシュを指定（オプション）
    string? fileHash = null;
    if (rangeTo == totalSize - 1)
    {
        // 必要に応じてファイルハッシュを計算
        // fileHash = ComputeSha256Hash(filePath);
    }
    
    var result = await client.UploadBinaryChunkAsync(
        siteId: 123,
        chunkData: chunkData,
        fileName: Path.GetFileName(filePath),
        rangeFrom: rangeFrom,
        rangeTo: rangeTo,
        rangeTotal: totalSize,
        contentType: "application/zip",
        fileHash: fileHash);
    
    if (result.Data?.StatusCode != 200)
    {
        Console.WriteLine($"チャンクアップロード失敗: {result.Data?.Message}");
        break;
    }
    
    offset += bytesRead;
    Console.WriteLine($"Progress: {offset}/{totalSize} ({(double)offset/totalSize*100:F1}%)");
}

Console.WriteLine("アップロード完了");
```

## 関連項目

- [バイナリ操作-01-バイナリ-取得(Base64)](08-バイナリ操作-01-バイナリ-取得(Base64).md)
- [バイナリ操作-02-バイナリ-ストリーム取得](08-バイナリ操作-02-バイナリ-ストリーム取得.md)
- [バイナリ操作-03-バイナリ-アップロード](08-バイナリ操作-03-バイナリ-アップロード.md) - Base64版アップロード
